<script src="config.js"></script>
<script>
// --- Global Quiz Data ---
const allQuizData = {
  quizSet1: {
    title: "Main Quiz (Life Cycles)",
    formId: "quizFormSet1", resultsId: "resultsSet1",
    mcq: { q1_1: "C", q1_2: "B", q1_3: "C", q1_4: "C", q1_5: "B" },
    fib: { q1_6: ["pupa"], q1_7: ["gills"], q1_8: ["seed"], q1_9: ["three", "3"], q1_10: ["moulting"]},
    match: { q1_16_frog: "C", q1_16_butterfly: "B", q1_16_grasshopper: "A", q1_16_chicken: "D" },
    shortAnswer: {
      q1_11: "The four stages are egg, larva, pupa, and adult.",
      q1_12: "A tadpole has a tail and breathes with gills, while an adult frog has legs and breathes with lungs.",
      q1_13: "Because it does not move or eat much while it changes into an adult inside a protective casing.",
      q1_14: "A young chicken (chick) looks like a smaller version of the adult, but a young butterfly (larva) looks completely different from the adult butterfly.",
      q1_15: "A seed needs water, warmth, and air (or oxygen) to germinate."
    },
    shortAnswerIds: ["q1_11", "q1_12", "q1_13", "q1_14", "q1_15"],
    totalQuestions: 19 // 5 MCQ + 5 FIB + 4 Match Items (counted as 4pts) + 5 SA
  },
  quizSet2: {
    title: "Revision Set 2: Definitions & Stages",
    formId: "quizFormSet2", resultsId: "resultsSet2",
    mcq: { q2_1: "A", q2_2: "B", q2_3: "C", q2_4: "B", q2_5: "D"},
    fib: { q2_6: ["fruits"], q2_7: ["larva"], q2_8: ["grows"], q2_9: ["larva", "caterpillar"], q2_10: ["seedling", "young plant"]},
    match: { q2_16_nymph: "C", q2_16_pupa: "A", q2_16_larva: "D", q2_16_germination: "B" },
    shortAnswer: {
      q2_11: "A life cycle shows all the stages of a living thing's life, from young to adult.",
      q2_12: "The larva stage is the eating and growing stage. For a butterfly, it is a caterpillar that eats leaves.",
      q2_13: "During the pupa stage, the larva transforms and changes its body shape into an adult.",
      q2_14: "The three main stages are seed, young plant (or seedling), and adult plant.",
      q2_15: "It means the nymph sheds its outer skin or exoskeleton so it can grow bigger."
    },
    shortAnswerIds: ["q2_11", "q2_12", "q2_13", "q2_14", "q2_15"],
    totalQuestions: 19
  },
  quizSet3: {
    title: "Revision Set 3: Application & Comparison",
    formId: "quizFormSet3", resultsId: "resultsSet3",
    mcq: { q3_1: "D", q3_2: "C", q3_3: "C", q3_4: "C", q3_5: "C" },
    fib: { q3_6: ["gills"], q3_7: ["pupa", "pupal"], q3_8: ["young", "chick"], q3_9: ["eggs"], q3_10: ["nymph"]},
    match: { q3_16_butterfly: "B", q3_16_frog: "A", q3_16_mosquito: "B", q3_16_cockroach: "A" },
    shortAnswer: {
      q3_11: "Both hatch from an egg. Also, their young look like smaller versions of the adults.",
      q3_12: "The young frog (tadpole) looks very different from the adult, but the young grasshopper (nymph) looks similar to the adult.",
      q3_13: "It is incorrect because a tadpole grows and changes into a frog (an amphibian), while a fish stays a fish its whole life.",
      q3_14: "It needs to eat a lot to store energy for the pupa stage, when it cannot eat at all.",
      q3_15: "You will need the first stage, which is a bean seed."
    },
    shortAnswerIds: ["q3_11", "q3_12", "q3_13", "q3_14", "q3_15"],
    totalQuestions: 19
  }
};

let currentQuizSetId = 'quizSet1';
const GEMINI_MODEL_NAME = "gemini-1.5-flash-latest";

function getFeedbackElement(id) { const el = document.getElementById(id); if (!el) console.error(`FB el ${id} not found!`); return el; }
function setFeedback(feedbackEl, message, type) { if (!feedbackEl) return; feedbackEl.innerHTML = message; feedbackEl.className = `feedback ${type}`; }

function showQuiz(quizId) {
  currentQuizSetId = quizId;
  document.querySelectorAll('.quiz-section').forEach(section => section.classList.remove('active'));
  document.getElementById(quizId).classList.add('active');
  document.querySelectorAll('.navigation-buttons button').forEach(btn => btn.classList.remove('active-nav'));
  
  // [FIX 2] Simplified and corrected the logic to find the active navigation button ID.
  const navButtonId = 'navBtn' + quizId.replace('quiz', ''); // e.g., 'quizSet1' becomes 'navBtnSet1'
  const activeButton = document.getElementById(navButtonId);
  if (activeButton) {
      activeButton.classList.add('active-nav');
  }

  for (const setId in allQuizData) { // Clear results of ALL quiz sets when switching
    const resultsEl = getFeedbackElement(allQuizData[setId].resultsId);
    if (resultsEl) resultsEl.innerHTML = '';
  }
}

async function evaluateMultipleShortAnswersWithGemini(shortAnswerData) {
  if (typeof geminiAPIKey === 'undefined' || !geminiAPIKey || geminiAPIKey === "YOUR_GEMINI_API_KEY_HERE" || geminiAPIKey === "__GEMINI_API_KEY_PLACEHOLDER__") {
    console.error("Gemini API Key is not defined or is a placeholder.");
    return shortAnswerData.map(item => ({ qid: item.id, result: 'Incorrect', explanation: '(Error: API Key not configured.)' }));
  }
  const GEMINI_API_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:generateContent?key=${geminiAPIKey}`;
  let promptContent = `You are an AI grading assistant for a P3 science quiz on Life Cycles. Evaluate each student's answer against its model answer. For EACH question, your response MUST be: QID:[question_id] Result:[Correct.|Incorrect.|Partially Correct.] Explanation:[Your P3-friendly explanation]||END_Q||. Example: QID:q1_11 Result:Correct. Explanation:Good.||END_Q||. No text before first QID or after last ||END_Q||. Questions:`;
  shortAnswerData.forEach(item => { promptContent += `\nQID: ${item.id}\nStudent: "${item.userInput}"\nModel: "${item.modelAnswer}"\n---\n`; });
  promptContent += "Provide evaluations in the specified format.";
  try {
    const response = await fetch(GEMINI_API_ENDPOINT, {
      method: "POST", headers: {"Content-Type": "application/json"},
      body: JSON.stringify({contents: [{ parts: [{ text: promptContent }] }], generationConfig: {temperature: 0.2, maxOutputTokens: 2048}})
    });
    if (!response.ok) {
      const err = await response.json().catch(() => ({error:{message:"Unknown API error"}}));
      console.error("Gemini API Error:", response.status, err);
      return shortAnswerData.map(item => ({ qid: item.id, result: 'Incorrect', explanation: `(API Error: ${err.error?.message||response.status})` }));
    }
    const data = await response.json();
    if (data.promptFeedback && data.promptFeedback.blockReason) {
        console.warn("Gemini API prompt blocked:", data.promptFeedback.blockReason, data.promptFeedback.safetyRatings);
        return shortAnswerData.map(item => ({ qid: item.id, result: 'Incorrect', explanation: `(API: Prompt blocked - ${data.promptFeedback.blockReason})` }));
    }
    if (data.candidates?.[0]?.finishReason !== "STOP") {
        console.warn("Gemini API response issue, Finish Reason:", data.candidates?.[0]?.finishReason);
        return shortAnswerData.map(item => ({ qid: item.id, result: 'Incorrect', explanation: `(API: Response issue - ${data.candidates?.[0]?.finishReason || 'Unknown'})` }));
    }
    if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
        console.error("Gemini API Error: Malformed response structure", data);
        return shortAnswerData.map(item => ({ qid: item.id, result: 'Incorrect', explanation: '(API Error: Malformed response.)' }));
    }
    const aiFullResponse = data.candidates[0].content.parts[0].text;
    const evaluations = {};
    aiFullResponse.split("||END_Q||").forEach(part => {
      if (!part.trim()) return;
      const qidMatch = part.match(/QID:([\w_]+)/);
      // [FIX 1] Made the regex for 'Result' flexible to accept words like "Partially Correct".
      const resultMatch = part.match(/Result:([\w\s]+\.)/);
      const explanationMatch = part.match(/Explanation:([\s\S]*)/); 
      if (qidMatch && resultMatch && explanationMatch) {
          evaluations[qidMatch[1]] = {
              qid: qidMatch[1],
              result: resultMatch[1].trim(),
              explanation: explanationMatch[1].trim()
          };
      } else {
          console.warn("Could not parse AI response part:", part);
          if (qidMatch && !evaluations[qidMatch[1]]) {
              evaluations[qidMatch[1]] = { qid: qidMatch[1], result: 'Incorrect', explanation: 'AI response format error.' };
          }
      }
    });
    return shortAnswerData.map(item => evaluations[item.id] || { qid: item.id, result: 'Incorrect', explanation: 'AI did not provide feedback.' });
  } catch (error) {
    console.error("General error during Gemini API call:", error);
    return shortAnswerData.map(item => ({ qid: item.id, result: 'Incorrect', explanation: `(JS Error: ${error.message})` }));
  }
}

async function submitQuiz(quizSetKey) {
  const quizDef = allQuizData[quizSetKey];
  if (!quizDef) { console.error("Invalid quizSetKey:", quizSetKey); return; }
  let score = 0, shortAnswersCorrect = 0;
  const form = document.getElementById(quizDef.formId);
  const resultsDiv = getFeedbackElement(quizDef.resultsId);
  form.querySelectorAll('.feedback').forEach(el => { el.innerHTML = ''; el.className = 'feedback'; });
  setFeedback(resultsDiv, "Processing...", "info");

  // --- Auto-grading section (MCQ, FIB, Matching) remains the same ---
  // MCQ
  Object.keys(quizDef.mcq).forEach(qName => {
    const fbEl = getFeedbackElement(`f${qName.substring(1)}`);
    const sel = form.querySelector(`input[name="${qName}"]:checked`);
    if (sel?.value === quizDef.mcq[qName]) { score++; setFeedback(fbEl, "Correct!", "correct"); }
    else if (sel) { setFeedback(fbEl, `Incorrect. Correct answer: ${quizDef.mcq[qName]}`, "incorrect"); }
    else { setFeedback(fbEl, "No answer selected.", "incorrect");}
  });
  // FIB
  Object.keys(quizDef.fib).forEach(qName => {
    const fbEl = getFeedbackElement(`f${qName.substring(1)}`);
    const uIn = form.querySelector(`input[name="${qName}"]`).value.trim().toLowerCase();
    const corr = quizDef.fib[qName];
    const isCorr = Array.isArray(corr) ? corr.includes(uIn) : uIn === corr;
    if (isCorr && uIn) { score++; setFeedback(fbEl, "Correct!", "correct"); }
    else if (uIn) { setFeedback(fbEl, `Incorrect. Correct answer: ${Array.isArray(corr)?corr.join(' or '):corr}`, "incorrect"); }
    else { setFeedback(fbEl, "No answer provided.", "incorrect"); }
  });
  // Matching
  let matchScore = 0;
  const matchPrefix = Object.keys(quizDef.match)[0]?.split('_').slice(0,2).join('_');
  if (matchPrefix && Object.keys(quizDef.match).length > 0) {
      const matchFbContainer = getFeedbackElement(`f${matchPrefix.substring(1)}`);
      if (matchFbContainer) matchFbContainer.innerHTML = '';
      Object.keys(quizDef.match).forEach(itemName => {
          const selEl = form.querySelector(`select[name="${itemName}"]`);
          const itemDispName = itemName.split('_').pop().replace(/^\w/, c => c.toUpperCase());
          const itemFbDiv = document.createElement('div');
          if (selEl && selEl.value) {
              if (selEl.value === quizDef.match[itemName]) {
                  matchScore++; itemFbDiv.textContent = `${itemDispName}: Correct!`; itemFbDiv.className = "feedback correct";
              } else {
                  itemFbDiv.textContent = `${itemDispName}: Incorrect. Correct: ${quizDef.match[itemName]}`; itemFbDiv.className = "feedback incorrect";
              }
          } else if (selEl) {
             itemFbDiv.textContent = `${itemDispName}: No answer selected.`; itemFbDiv.className = "feedback incorrect";
          }
          if (matchFbContainer && selEl) matchFbContainer.appendChild(itemFbDiv);
      });
      score += matchScore;
  }
  // --- End of Auto-grading section ---

  const autoGradedScore = score;
  const numMcq = Object.keys(quizDef.mcq).length;
  const numFib = Object.keys(quizDef.fib).length;
  const numMatchItems = Object.keys(quizDef.match).length;
  const autoGradedTotalForDisplay = numMcq + numFib + numMatchItems;

  setFeedback(resultsDiv, `Auto-graded: ${autoGradedScore}/${autoGradedTotalForDisplay}. Evaluating short answers...`, "info");

  const shortAnswersToEval = [];
  quizDef.shortAnswerIds.forEach(qId => {
    const fbEl = getFeedbackElement(`f${qId.substring(1)}`);
    const uIn = form.querySelector(`input[name="${qId}"]`).value.trim();
    if (uIn) {
        shortAnswersToEval.push({id: qId, userInput: uIn, modelAnswer: quizDef.shortAnswer[qId]});
        if(fbEl) setFeedback(fbEl, "Queued for AI checking...", "loading");
    } else {
        if(fbEl) setFeedback(fbEl, "No answer provided.", "incorrect");
    }
  });

  if (shortAnswersToEval.length > 0) {
    const aiEvals = await evaluateMultipleShortAnswersWithGemini(shortAnswersToEval);
    aiEvals.forEach((evalData) => {
      const fbEl = getFeedbackElement(`f${evalData.qid.substring(1)}`);
      const fullFeedbackMessage = `Result: ${evalData.result} ${evalData.explanation}`;
      
      // Award point only for an exact "Correct." result
      if (evalData.result.toLowerCase() === "correct.") {
        shortAnswersCorrect++;
        setFeedback(fbEl, fullFeedbackMessage, "correct");
      } else {
        // Style as "incorrect" for both "Incorrect." and "Partially Correct."
        setFeedback(fbEl, fullFeedbackMessage, "incorrect");
      }
    });
  }
  score += shortAnswersCorrect;
  setFeedback(resultsDiv, `Final Score for ${quizDef.title}: ${score} / ${quizDef.totalQuestions}`, "info");
}

document.addEventListener('DOMContentLoaded', () => {
  if (typeof geminiAPIKey==='undefined' || geminiAPIKey==="__GEMINI_API_KEY_PLACEHOLDER__" || geminiAPIKey === "YOUR_GEMINI_API_KEY_HERE") {
    const resDiv1 = getFeedbackElement(allQuizData.quizSet1.resultsId);
    let warnMsg = "Warning: API Key placeholder. ";
    if (window.location.hostname.includes('github.io')) warnMsg += "Action might not have processed config.js.";
    else warnMsg += "Expected locally. AI grading won't work.";
    if(resDiv1) setFeedback(resDiv1, warnMsg, "incorrect");
    console.warn(warnMsg);
  }
  showQuiz('quizSet1'); // Show the first quiz by default
});
</script>
